type: link
name: XSL:FO
location: https://en.wikipedia.org/wiki/XSL_Formatting_Objects
description: |
    XSL Formatting Objects is a markup language for XML document formatting that is most often used to generate PDF files. XSL-FO is part of XSL (Extensible Stylesheet Language), a set of W3C technologies designed for the transformation and formatting of XML data. The other parts of XSL are XSLT and XPath. Version 1.1 of XSL-FO was published in 2006. 
    
    XSL-FO is considered feature complete by W3C
notes:
    - no single processor (FOP, Antenna House, etc) 100% supports XSL:FO
---
type: link
name: XFA
location: https://en.wikipedia.org/wiki/XFA
description: XFA (also known as XFA forms) stands for XML Forms Architecture, a family of proprietary XML specifications that was suggested and developed by JetForm to enhance the processing of web forms. It can be also used in PDF files starting with PDF 1.5 specification. XFA specification is referenced as an external specification indispensable for the application of ISO 32000-1 specification (PDF 1.7). XML Forms Architecture was not standardized as an ISO standard.
notes:
    - avoid
    - not standard
    - not 'open'
    - "most pdf processors do not handle XFA content"
---
type: link
name: Apache FOP
location: https://en.wikipedia.org/wiki/Apache_FOP_(Formatting_Objects_Processor)
description: Formatting Objects Processor (FOP, also known as Apache FOP) is a Java application that converts XSL Formatting Objects (XSL-FO) files to PDF or other printable formats. FOP is open source software, and is distributed under the Apache License 2.0.
notes:
    - "Most important elements added in XSL-FO 1.1 (flow maps, table markers, indexes. etc.) are not available"
    - "older XSL-FO 1.0 features are still not fully supported including automatic table layout, floats and more."
    - multiple output formats with PDF being the best, but also ASCII, postscript, image formats, Java2D
---
type: link
name: TCPDF
location: https://github.com/tecnickcom/tcpdf
description: PHP library for generating PDF documents on-the-fly.
notes:
    - "A new version of this library is under development at https://github.com/tecnickcom/tc-lib-pdf and as a consequence this version will not receive any additional development or support. This version should be considered obsolete ..."
    - new version isn't complete or stable
    - I still see development happening
---
type: elife-xml-to-pdf-candidate
name: JATS2LaTeX -> pdflatex -> PDF
conversion-type: JATS -> LaTeX -> PDF
location: https://github.com/Vitaliy-1/JATS2LaTeX
references:
    - https://forum.pkp.sfu.ca/t/jats-xml-to-pdf-converter/30554
licence: GPL3
languages:
    - java
    - tex
    - latex
    - texlive (pdflatex)
examples:
    - https://github.com/Vitaliy-1/JATS2LaTeX/tree/master/example
evaluation:
    - an example of a sprawling barely-structured codebase relying on a specific idiomatic usage of JATS
    - does not work 09560 v1 xml, a null pointer exception traced to extraction of metadata
    - immature code, immature codebase
    - verbose code
    - lots of repetition
    - no architecture to allow extending or customising
decision:
    - avoid
---
type: elife-xml-to-pdf-candidate
name: CaSSius
conversion-type: XML -> HTML+CSS+JS -> PDF
location: https://github.com/MartinPaulEve/CaSSius
description: a tool to create beautiful paginated PDF documents from HTML content using CSS regions
references:
    - https://www.martineve.com/2016/06/19/cassius-now-supports-full-headless-pdf-creation-from-jats/
licence: AGPL3
languages:
    - xslt
    - python
    - html/css
    - javascript
examples:
    - https://www.martineve.com/cassius/sample.pdf
notes:
    - feels like a kludge of web technologies
    - the XML -> HTML+etal step is a mix of Python and xsl
    - no tests
    - output examples are ok, but not *that* great. I mean, the author really talks up how pretty the results are
    - from the javascript, it looks like the pages are being added after the polyfill. 
    - loading just the html (for inspecting) causes firefox to slow down and timeout constantly. I have no idea what is causing it
evaluation:
    - generating the special HTML required for cassius was straight forward
    - the browser rendering (firefox 62.0.3) displayed incorrectly with all pages on the first page and 49 blank pages
    - browser rendering was quite slow
    - browser printing was very slow
    - headless printing with wkhtmlpdf is not so bad
    - javascript is broken and the distinction between print/screen is ambiguous when using firefox/chrome to debug, which is infuriating
decision:
    - skip cassius unless we do it from scratch and understand what is happening at each step, including the xslt
    - out of the box it doesn't work for elife xml
    - with some hours of debugging and tweaking it still doesn't work
---
type:elife-xml-to-pdf-candidate
name: Pandoc
location: http://pandoc.org/MANUAL.html
description: Pandoc is a Haskell library for converting from one markup format to another
references:
    - http://pandoc.org/MANUAL.html#input-formats
notes:
    - pandoc support JATS XML as an input (reader) and output (writer)
    - support is still *alpha* quality
        - ref: https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/JATS.hs#L27
    - Ubuntu 18.10 has a recent enough version to use
    - works but converting to an intermediate 'Pandoc' type
    - the output template to be used can be seen with `--print-default-template=latex`
    - custom output templates can be provided with `--template`
    - if our usage of JATS is *more* descriptive than the Pandoc type, the transformation will be lossy
    - we might be able to see what is lost by doing XML->PANDOC->XML and comparing in vs out
    - is the JATS reader lossy? [yes]. will it read everything? [no] https://github.com/jgm/pandoc/blob/master/src/Text/Pandoc/Readers/JATS.hs
        - 'abstract' is not being read, for example
        - to modify you'll need to learn haskell
        - it *is* wonderfully compact code
evaluation:
    - there seems to be little in the way of translating jats XML->latex, I thought there would be more
    - pdf output out of the box is impressive in terms of coverage
        - bookmarks, footnotes present
        - no images yet but I was only targeting the xml
        - tables are absent
        - abstract is absent
    - the conversion from XML->latex is lossy
    - to capture the missing bits, custom filters would have to be written for the Pandoc AST, or the haskell reader modified
    - filters: https://pandoc.org/filters.html
    - we already have an elife-XML->JSON scraper (elife-tools+bot-lax)
    - the latex template used by Pandoc could very easily be translated to mustache/jinja/whatever and combined with the article-json
decision:
    - promising
    - if we are really keen on making this usable by non-elife people, we would go with pandoc and learn haskell or write loads of filter code

---
type:elife-xml-to-pdf-candidate
name: NCBI NLM Preview XSLT stylesheets
location: https://github.com/ncbi/JATSPreviewStylesheets
description: These stylesheets provide preview display of journal articles tagged using NISO JATS version 1.0 
references:
    - https://www.ncbi.nlm.nih.gov/books/NBK189779/
notes:
    - only Saxon HE (Home Edition) is Open Source
    - the guide on this site is recommending stylesheets that require paid-for versions of Saxon (PE and higher)
    - Apache FOP can't handle the transformation of xml to fo using xsl
    - using Saxon to generate the .fo file and FOP to generate the pdf, you *almost* get there.
    - adding euclid for the mathml helps
    - still left with two java stacktraces that offer zero insight into what the problem is
    - cutting out sections of the fo file and re-running the transformation isn't a great way to debug
    - no success, see notes.txt
---
type:elife-xml-to-pdf-candidate
name: JATSKit Preview XSLT stylesheets
location: https://github.com/wendellpiez/JATSKit
description: This oXygen framework supports editing JATS articles (v1.1) ... Included are DTDs, CSS files for authoring, document templates, XSLT stylesheets and other utilities for editing of JATS XML and production of HTML, PDF (preview) and EPUB outputs.
notes:
    - discovered while debugging problems in the NCBI NLM fo outputs
    - different stylesheets will generate different fo files which may have fewer issues being transformed into PDF files

---
type:elife-xml-to-pdf-candidate
name: Paged Media
location: https://print-css.rocks/intro.html
description: CSS Paged Media (a W3C standard) is a way to generate PDF documents from XML/HTML as input and CSS for styling.
references:
    - https://www.zopyx.com/news/print-css-rocks-pdf-converter-comparison
examples:
    - https://print-css.rocks/references.html
notes:
    - website is a front for a for-profit proprietary-orientated organisation "zopyx"
    - all examples are using proprietary and expensive technology
    - paged media is still quite immature right now
    - no wikipedia page?
    - doubtful of consistency of rendering going forwards
---
type:elife-xml-to-pdf-candidate
name: elife article-json to pdf 
description: uses elife's article-json generator to create a JSON structure and then [some custom tool] to generate a PDF
---
type:elife-xml-to-pdf-candidate
name: peerj jats-converstion to html, html to pdf
location: https://github.com/PeerJ/jats-conversion
description: This repository contains: XSL files for conversion from JATS XML to various other formats.
notes:
    - simpler example of converting from jats to html and then html to pdf than cassius
---
type: tool
name: weasyprint
description: python html->pdf tool
notes:
    - couldn't install a headless version (i.e. it pulled in all of xorg with libpango1.0)
    - generated PDF out of the box isn't any better or worse than wkhtmlpdf
    - wkhtmlpdf doesn't come with a boatload of dependencies however
    - there are some opinions that it is less robust than wkhtmlpdf and fails randomly
---
type:document,filename:README.md
content-type:markdown
content: <<EOF
# JATS->PDF

A review of the current state of automated JATS XML to PDF conversion tools.

## goals

* evaluate suitable *open source* tools
* test ~10 representative articles
* state a recommendation
* state why others should not be recommended

## dimensions

* speed - average speed from XML->PDF
* complexity - number of technologies involved
* extensibility - modifying the technologies to alter the PDF appearance
* robustness - how well the stack handles errors and a variety of inputs
* support - likelihood of finding answers to difficult questions

## targets

* pandoc
* cassius
* official jats-xslt-stylesheets

## results

See [results](results.md)

## installation

Requirements

* Docker is used to describe the environments each candidate is run in
* public eLife article data

## running all transformations

Article data can be downloaded with:

    ./download-articles.sh
    
The initial environment can be built with:

    ./run.sh

This will build the Docker images and create a file `built.flag` that prevents the containers from being built by `./run.sh` again.

Use `./run.sh` again to start the testing process.

Generated pdf files are copied to the directory `./pdf/` as `transformer--article-id.pdf`.

stdout and stderr are written to `./log/` as `transformer--article-id.log`

## running individual transformations

Each candidate has it's own `build.sh`, `run.sh`, `shell.sh` and `transform.sh` scripts.

* `./build.sh` will tell Docker to build the current Dockerfile
* `./run.sh` accepts an input xml file or article directory and an output pdf filename
* `./transform.sh` is copied into the container during the build and executed during the run`
* `./shell.sh` will drop you into a shell within the Docker container for debugging

For example:

    cd pandoc
    ./build.sh
    ./run.sh /path/to/article.xml article.pdf

The artifacts of a transformation live in the `./mnt` directory. This directory is shared with the Docker container and
is available within the container as `/mnt` (note the missing leading `.`).

EOF
---
type:document
content-format: markdown
content: <<EOF
# Automated JATS XML to PDF conversion

JATS is a specification for describing articles. The specification is clear on how articles must be described however it's possible for the same article to be described in different ways by different authors and still fulfill the requirements of the specification. Authors themselves may also vary how they describe documents over time. This introduces the problem of how to treat JATS documents uniformly across authors and time so that all instances of JATS XML may benefit from common tools.

eLife has the final PDF version of an article hand-made because:

* automated conversions do not *quite* approach the precision of manual print design
* most articles are not read on the publisher's site in HTML form but in PDF or printed form elsewhere. The quality of the PDF contributes to a good first impression.
* authors often feel the version of their submitted article to be the best formatted version and any clumsiness introduced with an automated approach to be a personal affront.
* it's cheap to outsource the PDF-creation labour
* expertise in the stack of technologies and languages that automate this process is relatively rare

This report is an evaulation of *pre-existing*, *open-source* technologies with a view to adoption during the article production process at eLife to:

* remove vendor dependency
* remove ability for authors to request changes to PDF
* share our work with other publishers

## results

The following were tested:

* [CaSSius](https://github.com/MartinPaulEve/CaSSius)
* [jats2latex](https://github.com/Vitaliy-1/JATS2LaTeX)
* [jats-xslt-stylesheets](https://github.com/ncbi/JATSPreviewStylesheets)
* [pandoc](http://pandoc.org/)
* [peerj-jats-conversion](https://github.com/PeerJ/jats-conversion)

None of the above is a single technology and all fall in to one of these categories:

* `XML->HTML->PDF` (CaSSius, peerj-jats-conversion)
* `XML->LaTeX->PDF` (pandoc, jats2latex)
* `XML->XSL-FO->PDF` (jats-xslt-stylesheets)

The transformation from `JATS XML` to `HTML` and `LaTeX` requires an intermediate scraper that navigates `XML` and produces `HTML` or `LaTeX`.

The transformation from `JATS XML` to `XSL-FO` objects requires `XSL`, a transformation language described in `XML`.

`jats2latex` failed to produce anything for any document it was tested on. I believe it was developed for a particular vendor's flavour of `JATS XML` and wasn't robust enough to handle variations. I've excluded it from hereonout.

The official NLM XSL and XSL-FO stylesheets rendered using the Apache FOP project has produced just a single successful result. There is not enough here to make any judgements on XSL-FO's suitability at all, just that out of the box, this particular stack doesn't work after much debugging.

The remaining tools are CaSSius, peerj-jats-conversion (both XML->HTML->PDF conversions) and Pandoc (XML->LaTeX->PDF).

The results have no images in them. This is because special eLife pre-processing of the XML is required to expand image tags to actual files.

## evaluation

1. ease. how convenient is it to style the PDF?
2. precision. how closely can we affect the PDF?
3. speed. how fast was the transformation?
4. stability. how often is the technology stack changing?

All values are measured 1 to 5, with 5 being very good, 1 very bad.

|                       |ease   |precision  |speed  |stability
|---                    |---    |---        |---    |---
|jats-xslt-stylesheets  |1      |5          |3      |5
|cassius                |3      |2          |1      |2
|peerj-jats-conversion  |4      |3          |2      |3
|Pandoc                 |4      |5          |4      |4

All values are my personal opinion. Timings for the conversions can be found in the [timings.csv](timings.csv) and the pdf results in [./pdf](./pdf)

### jats-xslt-stylesheets

These are official stylesheets in XSLT 1.0 and 2.0 formats and optional XPROC support. They are strict about refusing changes to the stylesheets that are presentational so there are no fancy examples here.

In this case I was attempting to generate PDF files by using the official stylesheets to generate XSL-FO files and then use Apache FOP to convert them into PDF files.

All attempts failed to generate a PDF except a relatively simple one. Debugging ended after Apache FOP stacktraces couldn't be resolved.

An example of a `.fo` file that is directly turned into a PDF can be found at `./jats-xslt-stylesheets/sample1.fo`. Writing XSL transformations to generate XSL-FO files would give you very precise control over the final PDF.

### CaSSius (HTML->PDF)

CaSSius is an attempt to use new web technologies such as Paged Media via [Polyfills](https://en.wikipedia.org/wiki/Polyfill_(programming)) to generate print-quality PDF files.

CaSSius works by passing JATS XML through an XSL stylesheet to generate HTML. The HTML contains CaSSius stylesheets and javascript that can be modified and inspected easily on smaller articles. The HTML is then passed to `wkhtmltopdf` ("Webkit HTML to PDF"), a headless browser, that executes the javascript and generates the PDF.

Unfortunately CaSSius fails to produce anything more than the single leading page across all documents. That said, that single page is attractively styled. The HTML opened in Firefox resembles the PDF that was printed, so in this respect `wkhtmltopdf` is quite accurate. Debugging the running javascript in Firefox was difficult as the debugger often crashed and everything was so sluggish it was frustrating to inspect. Changes made in the inspector were not reflected in the browser.

More recent articles at [Orbit](https://orbit.openlibhums.org/) are an example of a journal using CaSSius.

### peerj-jats-conversion (HTML->PDF)

PeerJ have a repository of tools used for validating and converting their own JATS XML to HTML. The conversion to PDF is done using `wkhtmltopdf`, just like CaSSius. 

The results have no special styling but it demonstrates that basic HTML to PDF *can* work well, that PDF bookmarks are present, links work, etc and that `wkhtmltopdf` isn't choking on larger articles.

### Pandoc (LaTeX->PDF)

Pandoc is well established software that converts text documents to any other format. It does this by parsing a text document into it's own internal representation of a document using 'readers' and then writing that document out using a 'writer'. Pandoc can also generate PDF documents by using LaTeX as an intermediate format. Pandoc has recently added a 'jats' reader and writer so that JATS XML can now be read in and then a PDF written out by first generating LaTeX.

The outputs are only as good as the internal representation of the document, which *may be incomplete or lossy*. Pandoc is a Haskell language program and the 'jats' reader is also written in Haskell, rather than XSL or Java.

The template that writers use can be seen with `pandoc -D <writer>`. These templates can be customised and used instead during the generation process. A customised LaTeX template can be found at `./pandoc/latex-template.tex` and an example of a populated template is `./pandoc/pandoc--31543-intermediate.tex`. It uses a straightforward templating language very similar to `mustache` or `jinja`.

After the document has been read but before it has been written, the document can be transformed in a fashion similar to XSL using languages like Lua or Python or Haskell. These transformations are called 'filters' and an example can be found at `./pandoc/abstract.py`. The process becomes `Reader->Filters->Writer`.

## Conclusions

There are two very large problems that can't be solved together: multitude of idiomatic JATS XML usage and a complete and precise rendering to PDF. I erred on simply  producing an article PDF than coercing eLife JATS XML into a more compatible shape but I was necessarily constrained by the generalised JATS handling in the software. A single strict specification that all idiomatic JATS XML can be transformed to would allow the subsequent conversion to PDF to be available to everybody. This is a whole other epic undertaking.

My next biggest concern is completeness. We absolutely should not have existential worries that bits of the final PDF are 'missing' because they were not parsed. XSL neatly avoids this problem most of the time, but Haskell (Pandoc) and Java (jats2latex) and Python (bot-lax-adaptor) and other 'code' approaches do not. They target specific sections, extract and transform. Unhandled elements will silently be ignored. For example, Pandoc's Haskell 'jats' reader doesn't extract the 'abstract' element. There is support in the output LaTeX template for displaying an abstract but to get at it we would need to extend or fork the Haskell code. Or wait for somebody else to fix it.

LaTeX felt wonderfully precise, stable and sophisticated. Pandoc as well, but perhaps too constrained in it's internal model for us.

The state of a HTML+CSS+JS, Paged Media and headless PDF printing stack felt like a hodge-podge of good intentions, much enthusiasm, sluggish W3C proposals, literal 'polyfill' javascript and hamfisting a traditionally non-print medium into a print one. Development and debugging on this stack will be frustrating. This stack will feel like the easiest route to most of us with web backgrounds and there *is* a lot of enthusiasm out there for a 'web native' approach, but overall it's terribly imprecise, slow and immature. The [print-css.rocks website](https://github.com/zopyx/print-css-rocks) has a number of 'lessons' that demonstrate various techniques of HTML->PDF, unfortunately most of them don't appear to very flattering when rendered with a headless browser. You can find my rendered outputs in the `./paged-media-output/` and the `./build-print-css-rocks-examples.sh` script to render your own.

The XSLT stack feels like the 'proper' approach, but the XSL idiom of transforming XML into other XML including XSL-FO is often alien to developers. It requires more than just learning another programming language, it requires learning a different programming paradigm altogether whose tools are unpopular, scorned and worst of all: old. The precision and speed of this stack would be second to none however, but so would the learning curve and expertise required to maintain it all.

## Suggestion

If eLife is prioritising a community effort to improve JATS->PDF tooling for all, I suggest pouring time and effort into Pandoc and JATS4R.

If the priority is more practical, I would suggest none of the above and that eLife use the article-json as generated by the bot-lax-adaptor with a LaTeX template. The benefits are:

* we are certain the eLife article-json is *complete*
* LaTeX will give us very precise control over the PDF presentation
* LaTeX can be templated like mustache or jinja, which is very familiar to the average developer
* LaTeX to PDF conversion is quick making the feedback loop short, which is important to development

EOF
